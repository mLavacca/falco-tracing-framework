diff --git a/CMakeLists.txt b/CMakeLists.txt
index f2bb7b7..b65ad36 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -47,6 +47,13 @@ endif()
 
 set(CMAKE_COMMON_FLAGS "-Wall -ggdb ${DRAIOS_FEATURE_FLAGS}")
 
+# Falco tracing
+if(FALCO_TRACE_FLAG STREQUAL "stacktrace")
+	add_definitions(-DTRACE_FALCO)
+elseif(FALCO_TRACE_FLAG STREQUAL "rules")
+	add_definitions(-DTRACE_FALCO_RULES)
+endif()
+
 if(BUILD_WARNINGS_AS_ERRORS)
 	set(CMAKE_SUPPRESSED_WARNINGS "-Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable -Wno-missing-field-initializers -Wno-sign-compare -Wno-type-limits -Wno-implicit-fallthrough -Wno-format-truncation")
 	set(CMAKE_COMMON_FLAGS "${CMAKE_COMMON_FLAGS} -Wextra -Werror ${CMAKE_SUPPRESSED_WARNINGS}")
diff --git a/userspace/engine/CMakeLists.txt b/userspace/engine/CMakeLists.txt
index 99d2ebe..5c33dda 100644
--- a/userspace/engine/CMakeLists.txt
+++ b/userspace/engine/CMakeLists.txt
@@ -26,7 +26,12 @@ set(FALCO_ENGINE_SOURCE_FILES
 	json_evt.cpp
 	ruleset.cpp
 	token_bucket.cpp
-	formats.cpp)
+	formats.cpp
+	../../../falco-plugin/tracer_interface.cpp
+	../../../falco-plugin/tracer.cpp	
+	../../../falco-plugin/tracer_common.cpp
+	../../../falco-plugin/tracer_msg_creator.cpp
+	../../../falco-plugin/tsc.cpp)
 
 add_library(falco_engine STATIC ${FALCO_ENGINE_SOURCE_FILES})
 
@@ -39,6 +44,7 @@ target_include_directories(falco_engine PUBLIC
 	"${SYSDIG_DIR}/userspace/libscap"
 	"${SYSDIG_DIR}/userspace/libsinsp"
 	"${PROJECT_BINARY_DIR}/userspace/engine"
+	"${PROJECT_SOURCE_DIR}/../falco-plugin"
 	)
 
 target_link_libraries(falco_engine
diff --git a/userspace/engine/falco_engine.cpp b/userspace/engine/falco_engine.cpp
index e3e8327..67dda62 100644
--- a/userspace/engine/falco_engine.cpp
+++ b/userspace/engine/falco_engine.cpp
@@ -35,6 +35,10 @@ extern "C" {
 
 #include "utils.h"
 
+#if TRACE_FALCO || TRACE_FALCO_RULES
+#include "../falco-plugin/tracer_interface.h"
+#endif
+
 
 string lua_on_event = "on_event";
 string lua_print_stats = "print_stats";
@@ -275,16 +279,45 @@ void falco_engine::syscalls_for_ruleset(std::vector<bool> &syscalls, const std::
 
 unique_ptr<falco_engine::rule_result> falco_engine::process_sinsp_event(sinsp_evt *ev, uint16_t ruleset_id)
 {
+
+#ifdef TRACE_FALCO
+	set_func_start(FALCO_ENGINE_SHOULD_DROP_EVT);
+#endif
+
 	if(should_drop_evt())
 	{
+
+	#ifdef TRACE_FALCO
+		inc_counter(EVENT_DROPPED_CNT);
+		set_func_end_cont(FALCO_ENGINE_SHOULD_DROP_EVT, EVENT_DROPPED_CNT, PROCESS_SINSP_EVENT);
+	#endif
+
 		return unique_ptr<struct rule_result>();
 	}
 
+#ifdef TRACE_FALCO
+	set_func_end(FALCO_ENGINE_SHOULD_DROP_EVT, PROCESS_SINSP_EVENT);
+#endif
+
+#ifdef TRACE_FALCO
+	set_func_start(RULESET_FILTERS_RUN);
+#endif
+
 	if(!m_sinsp_rules->run(ev, ruleset_id))
 	{
+
+	#ifdef TRACE_FALCO
+		inc_counter(RULES_NOT_BROKEN_CNT);
+		set_func_end_cont(RULESET_FILTERS_RUN, RULES_NOT_BROKEN_CNT, PROCESS_SINSP_EVENT);
+	#endif
+
 		return unique_ptr<struct rule_result>();
 	}
 
+#ifdef TRACE_FALCO
+	set_func_end(RULESET_FILTERS_RUN, PROCESS_SINSP_EVENT);
+#endif
+
 	unique_ptr<struct rule_result> res(new rule_result());
 
 	lua_getglobal(m_ls, lua_on_event.c_str());
@@ -522,3 +555,34 @@ json_event_filter_factory &falco_engine::json_factory()
 
 	return *(m_json_factory.get());
 }
+
+#if TRACE_FALCO || TRACE_FALCO_RULES
+void falco_engine::send_rules_names_engine()
+{
+	start_rules_names_sending();
+
+	for(int i = 0; i < N_RULES; i++)
+	{
+		lua_getglobal(m_ls, lua_on_event.c_str());
+
+		if(lua_isfunction(m_ls, -1))
+		{
+			lua_pushnumber(m_ls, i);
+			if(lua_pcall(m_ls, 1, 3, 0) != 0)
+			{
+				continue;
+			}
+		
+			const char *p =  lua_tostring(m_ls, -3);
+			send_rule_name(i, p);
+			lua_pop(m_ls, 3);
+		}
+		else
+		{
+			throw falco_exception("No function " + lua_on_event + " found in lua compiler module");
+		}
+	}
+
+	end_rules_names_sending();
+}
+#endif
diff --git a/userspace/engine/falco_engine.h b/userspace/engine/falco_engine.h
index de7da08..b0b138e 100644
--- a/userspace/engine/falco_engine.h
+++ b/userspace/engine/falco_engine.h
@@ -233,6 +233,10 @@ public:
 			      std::set<uint32_t> &syscalls,
 			      std::set<std::string> &tags,
 			      sinsp_filter* filter);
+	
+#if TRACE_FALCO || TRACE_FALCO_RULES
+	void send_rules_names_engine();
+#endif
 
 	sinsp_filter_factory &sinsp_factory();
 	json_event_filter_factory &json_factory();
diff --git a/userspace/engine/falco_engine_version.h b/userspace/engine/falco_engine_version.h
index e77bd1a..805b99c 100644
--- a/userspace/engine/falco_engine_version.h
+++ b/userspace/engine/falco_engine_version.h
@@ -24,4 +24,4 @@ limitations under the License.
 // This is the result of running "falco --list -N | sha256sum" and
 // represents the fields supported by this version of falco. It's used
 // at build time to detect a changed set of fields.
-#define FALCO_FIELDS_CHECKSUM "ceb069d9f9b2d4ebcc5de39bddc53b7af2e6b8f072edc293668fd6ac4e532413"
+#define FALCO_FIELDS_CHECKSUM "8778e4bdb3d6ce4e3220e8a3911f46f7a07f9d48f9708fe911cac1d70bcfbf90"
diff --git a/userspace/engine/ruleset.cpp b/userspace/engine/ruleset.cpp
index 57ed0ef..9ba0dbc 100644
--- a/userspace/engine/ruleset.cpp
+++ b/userspace/engine/ruleset.cpp
@@ -19,6 +19,10 @@ limitations under the License.
 
 #include "ruleset.h"
 
+#if TRACE_FALCO || TRACE_FALCO_RULES
+#include "../falco-plugin/tracer_interface.h"
+#endif
+
 using namespace std;
 
 falco_ruleset::falco_ruleset()
@@ -146,12 +150,31 @@ bool falco_ruleset::ruleset_filters::run(gen_event *evt, uint32_t etag)
 		return false;
 	}
 
+#ifdef TRACE_FALCO_RULES
+	set_current_tag(etag);
+#endif
+
 	for (auto &wrap : *filters)
 	{
+
+	#ifdef TRACE_FALCO_RULES
+		set_rule_start();
+	#endif
+
 		if(wrap->filter->run(evt))
 		{
+
+		#ifdef TRACE_FALCO_RULES
+			set_rule_end(true);
+		#endif
+
 			return true;
 		}
+
+	#ifdef TRACE_FALCO_RULES
+		set_rule_end(false);
+	#endif
+
 	}
 
 	return false;
diff --git a/userspace/falco/CMakeLists.txt b/userspace/falco/CMakeLists.txt
index fb5b535..fd6748a 100644
--- a/userspace/falco/CMakeLists.txt
+++ b/userspace/falco/CMakeLists.txt
@@ -40,6 +40,17 @@ target_include_directories(falco PUBLIC
 	"${CIVETWEB_INCLUDE_DIR}"
 	"${DRAIOS_DEPENDENCIES_DIR}/yaml-${DRAIOS_YAML_VERSION}/target/include")
 
+if(TRACE_FALCO)
+	add_executable(falco
+		../../../falco-plugin/tracer_interface.cpp
+		../../../falco-plugin/tracer.cpp	
+		../../../falco-plugin/tracer_common.cpp
+		../../../falco-plugin/tracer_msg_creator.cpp
+		../../../falco-plugin/tsc.cpp)
+	
+	include_directories("${PROJECT_SOURCE_DIR}/../falco-plugin")
+endif()
+
 target_link_libraries(falco falco_engine sinsp)
 target_link_libraries(falco
 	"${LIBYAML_LIB}"
diff --git a/userspace/falco/falco.cpp b/userspace/falco/falco.cpp
index 0f13649..09f7fa0 100644
--- a/userspace/falco/falco.cpp
+++ b/userspace/falco/falco.cpp
@@ -55,6 +55,17 @@ bool g_reopen_outputs = false;
 bool g_restart = false;
 bool g_daemonized = false;
 
+#if TRACE_FALCO || TRACE_FALCO_RULES
+#include "../falco-plugin/tracer_interface.h"
+
+falco_engine *engine = NULL;
+
+void send_rules_names_wrapper(int signum)
+{
+	engine->send_rules_names_engine();
+}
+#endif
+
 //
 // Helper functions
 //
@@ -259,10 +270,31 @@ uint64_t do_inspect(falco_engine *engine,
 	while(1)
 	{
 
+	#ifdef TRACE_FALCO
+		reset_last_counter();
+		set_func_start(ANALYSIS_CYCLE);
+	#endif
+
+	#ifdef TRACE_FALCO
+		set_func_start(SINSP_NEXT);
+	#endif
+
 		rc = inspector->next(&ev);
+	
+	#ifdef TRACE_FALCO
+		set_func_end(SINSP_NEXT, ANALYSIS_CYCLE);
+	#endif
+
+	#ifdef TRACE_FALCO
+		set_func_start(STATS_FILE_WRITER_HANDLE);
+	#endif
 
 		writer.handle();
 
+	#ifdef TRACE_FALCO
+		set_func_end(STATS_FILE_WRITER_HANDLE, ANALYSIS_CYCLE);
+	#endif
+
 		if(g_reopen_outputs)
 		{
 			outputs->reopen_outputs();
@@ -276,10 +308,17 @@ uint64_t do_inspect(falco_engine *engine,
 		}
 		else if(rc == SCAP_TIMEOUT)
 		{
+		#ifdef TRACE_FALCO
+			inc_counter(SCAP_TIMEOUT_CNT);
+			set_func_end_cont(ANALYSIS_CYCLE, SCAP_TIMEOUT_CNT, ROOT);
+		#endif
 			continue;
 		}
 		else if(rc == SCAP_EOF)
 		{
+		#if TRACE_FALCO || TRACE_FALCO_RULES
+			write_scap_file_stats();
+		#endif
 			break;
 		}
 		else if(rc != SCAP_SUCCESS)
@@ -303,29 +342,72 @@ uint64_t do_inspect(falco_engine *engine,
 			}
 		}
 
+	#ifdef TRACE_FALCO
+		set_func_start(SYSCALL_EVT_DROP_MGR_PROCESS_EVENT);
+	#endif
+
 		if(!sdropmgr.process_event(inspector, ev))
 		{
 			result = EXIT_FAILURE;
 			break;
 		}
 
+	#ifdef TRACE_FALCO
+		set_func_end(SYSCALL_EVT_DROP_MGR_PROCESS_EVENT, ANALYSIS_CYCLE);
+	#endif
+
+	#ifdef TRACE_FALCO
+		set_func_start(EV_FALCO_CONSIDER);
+	#endif
+
 		if(!ev->falco_consider() && !all_events)
 		{
+		#ifdef TRACE_FALCO
+			inc_counter(EVENT_NOT_CONSIDERED_CNT);
+			set_func_end_cont(EV_FALCO_CONSIDER, EVENT_NOT_CONSIDERED_CNT, ANALYSIS_CYCLE);
+			set_func_end_cont(ANALYSIS_CYCLE, CYCLE_COMPLETED_CNT, ROOT);
+		#endif
 			continue;
 		}
+	#ifdef TRACE_FALCO
+		set_func_end(EV_FALCO_CONSIDER, ANALYSIS_CYCLE);
+	#endif
 
 		// As the inspector has no filter at its level, all
 		// events are returned here. Pass them to the falco
 		// engine, which will match the event against the set
 		// of rules. If a match is found, pass the event to
 		// the outputs.
+	#ifdef TRACE_FALCO
+		set_func_start(PROCESS_SINSP_EVENT);
+	#endif
+
 		unique_ptr<falco_engine::rule_result> res = engine->process_sinsp_event(ev);
+
+	#ifdef TRACE_FALCO
+		set_func_end(PROCESS_SINSP_EVENT, ANALYSIS_CYCLE);
+	#endif
+	
 		if(res)
 		{
+		#ifdef TRACE_FALCO
+			set_func_start(FALCO_OUTPUTS_HANDLE_EVENT);
+		#endif
+
 			outputs->handle_event(res->evt, res->rule, res->source, res->priority_num, res->format);
+			
+			
+		#ifdef TRACE_FALCO
+			set_func_end(FALCO_OUTPUTS_HANDLE_EVENT, ANALYSIS_CYCLE);
+			inc_counter(CYCLE_COMPLETED_CNT);
+		#endif
 		}
 
-		num_evts++;
+	#ifdef TRACE_FALCO
+		set_func_end_cont(ANALYSIS_CYCLE, CYCLE_COMPLETED_CNT, ROOT);
+	#endif
+
+		num_evts++;	
 	}
 
 	return num_evts;
@@ -397,7 +479,11 @@ int falco_init(int argc, char **argv)
 	int result = EXIT_SUCCESS;
 	sinsp* inspector = NULL;
 	sinsp_evt::param_fmt event_buffer_format = sinsp_evt::PF_NORMAL;
+
+#if !TRACE_FALCO && !TRACE_FALCO_RULES
 	falco_engine *engine = NULL;
+#endif
+
 	falco_outputs *outputs = NULL;
 	syscall_evt_drop_mgr sdropmgr;
 	int op;
@@ -511,6 +597,11 @@ int falco_init(int argc, char **argv)
 				disabled_rule_substrings.insert(substring);
 				break;
 			case 'e':
+
+			#if TRACE_FALCO || TRACE_FALCO_RULES
+				set_analysis_type(OFFLINE_ANALYSIS);
+			#endif
+
 				trace_filename = optarg;
 				k8s_api = new string();
 				mesos_api = new string();
@@ -649,6 +740,10 @@ int falco_init(int argc, char **argv)
 			}
 
 		}
+	
+	#if TRACE_FALCO  || TRACE_FALCO_RULES
+		init_tracer();
+	#endif
 
 		inspector = new sinsp();
 		inspector->set_buffer_format(event_buffer_format);
@@ -949,6 +1044,23 @@ int falco_init(int argc, char **argv)
 			goto exit;
 		}
 
+	#if TRACE_FALCO || TRACE_FALCO_RULES
+		if(get_analysis_type() == ONLINE_ANALYSIS)
+		{
+			if(signal(SEND_RULES_NAMES, send_rules_names_wrapper) == SIG_ERR)
+			{
+				fprintf(stderr, "An error occurred while setting SEND_RULES_NAMES signal handler.\n");
+				result = EXIT_FAILURE;
+				goto exit;
+			}
+		} 
+		else
+		{
+			engine->send_rules_names_engine();
+		}	
+	#endif
+
+
 		// If daemonizing, do it here so any init errors will
 		// be returned in the foreground process.
 		if (daemon && !g_daemonized) {
@@ -1239,5 +1351,10 @@ int main(int argc, char **argv)
 		optind = 1;
 	}
 
+#if TRACE_FALCO || TRACE_FALCO_RULES
+	close_tracer();	
+#endif
+
+
 	return rc;
 }
